import {Standard} from '@browseth/internal-types';
import {ABI, IMethod} from '@browseth/abi';
import {JsonInterface} from '@browseth/internal-types';

interface IMethodWrapper {
  send: (transaction: any, ...params: any[]) => Promise<ArrayBuffer>;
  estimate: (
    transaction: any,
    tag: 'pending' | 'latest' | 'earliest' | BigNumber,
    ...params: any[]
  ) => Promise<BigNumber>;
  call: (
    transaction: any,
    tag: 'pending' | 'latest' | 'earliest' | BigNumber,
    ...params: any[]
  ) => Promise<any>;
  encode: (...params: any[]) => string;
}

export class Contract {
  public methods: {[key: string]: IMethodWrapper} = {};
  private abi: ABI;
  constructor(
    private c: Standard.NodeMethods,
    public jsonInterface: JsonInterface.JSONInterface,
    public strict: boolean = true,
  ) {
    this.abi = new ABI(jsonInterface);

    this.abi.methods.forEach(v => {
      const wrapper: IMethodWrapper = {
        send: async (transaction, ...params) => {
          if (
            (strict && (v.payable === false && transaction.value)) ||
            v.constant === true
          ) {
            throw new Error(
              `send of transaction<${transaction}> is incompatable with v<${v}>`,
            );
          }

          return this.c.sendTransaction({
            ...transaction,
            data: v.enc(params),
          });
        },
        estimate: async (transaction, tag, ...params) => {
          if (
            (strict && (v.payable === false && transaction.value)) ||
            v.constant === true
          ) {
            throw new Error(
              `estamate of transaction<${transaction}> is incompatable with v<${v}>`,
            );
          }

          return this.c.estimateGas({...transaction, data: v.enc(params)}, tag);
        },
        call: async (transaction, tag, ...params) => {
          if (strict && (v.payable === false && transaction.value)) {
            throw new Error(
              `call of transaction<${transaction}> is incompatable with v<${v}>`,
            );
          }

          const resp = await this.c.ethCall(
            {...transaction, data: v.enc(params)},
            tag,
          );

          return v.dec(resp);
        },
        encode: (...params: any[]) => v.enc(params),
      };

      if (v.name) {
        this.methods[v.name] = wrapper;
      }
      this.methods[v.sig] = wrapper;
    });

    // this.abi.events.forEach(v => {
    // 	// TODO: Event Binding
    // });
  }
}
