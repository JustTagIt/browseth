import BigNumber from 'bignumber.js';

interface TypeDef {
  type: string[];
  [k: string]: any;
}

const TBoolean = {type: ['boolean']};
const EBoolean = <boolean>false;

const TString = {type: ['string']};
const EString = <string>'';

const TVoid = {type: ['void']};
const EVoid = <void>undefined;

type IData = ArrayBuffer | string;
type IQuantity = BigNumber | number | string;
type ITag = 'earliest' | 'latest' | 'pending' | IQuantity;
type OData = ArrayBuffer;
type OQuantity = string;

const TData = (bytes?: number) => ({type: ['data'], bytes});
const TQuantity = {type: ['quantity']};
const TTag = {type: ['tag']};

const TTuple = (...types: TypeDef[]) => ({type: ['tuple'], items: [...types]});
const TArray = (type: TypeDef) => ({type: ['array'], itemType: type});
const TObject = (props: {[k: string]: TypeDef}) => ({type: ['object'], props});

const TMergeOne = (type1: TypeDef, type2: TypeDef) => {
  return {...type1, ...type2, type: [...type1.type, ...type2.type]};
};
const TMerge = (...types: TypeDef[]) => types.reduce((a, v) => TMergeOne(a, v));
const TOptional = (type: TypeDef) => {
  return TMergeOne(type, TVoid);
};

interface OLog {
  removed: boolean;
  logIndex: OQuantity;
  transactionIndex: OQuantity;
  transactionHash: OData;
  blockHash: OData;
  blockNumber: OQuantity;
  address: OData;
  data: OData;
  topics: Array<OData | [OData, OData]>;
}

const TLog = TObject({
  removed: TBoolean,
  logIndex: TQuantity,
  transactionIndex: TQuantity,
  transactionHash: TData(),
  blockHash: TData(),
  blockNumber: TQuantity,
  address: TData(),
  data: TData(),
  topics: TArray(TMerge(TData(32), TTuple(TData(32), TData(32)))),
});

interface OTransactionReceipt {
  transactionHash: OData;
  transactionIndex: OQuantity;
  blockHash: OData;
  blockNumber: OQuantity;
  cumulativeGasUsed: OQuantity;
  gasUsed: OQuantity;
  contractAddress: OQuantity;
  logs: ReadonlyArray<OLog>;
  logsBloom: OData;
  root: OData;
  status: OData;
}

const TTransactionReceipt = TObject({
  transactionHash: TData(32),
  transactionIndex: TQuantity,
  blockHash: TData(32),
  blockNumber: TQuantity,
  cumulativeGasUsed: TQuantity,
  gasUsed: TQuantity,
  contractAddress: TQuantity,
  logs: TArray(TLog),
  logsBloom: TData(256),
  root: TOptional(TData(32)),
  status: TOptional(TData()),
});

interface OTransactionObject {
  hash: OData;
  nonce: OQuantity;
  blockHash: OData;
  blockNumber: OQuantity;
  transactionIndex: OQuantity;
  from: OData;
  to?: OData;
  value: OQuantity;
  gasPrice: OQuantity;
  gas: OQuantity;
  input: OData;
}

const TTransactionObject = TObject({
  hash: TData(32),
  nonce: TQuantity,
  blockHash: TData(32),
  blockNumber: TQuantity,
  transactionIndex: TQuantity,
  from: TData(20),
  to: TOptional(TData(20)),
  value: TQuantity,
  gasPrice: TQuantity,
  gas: TQuantity,
  input: TData(),
});

interface OBlockObject {
  number?: OQuantity;
  hash?: OData;
  parentHash: OData;
  nonce?: OData;
  sha3Uncles: OData;
  logsBloom?: OData;
  transactionsRoot: OData;
  stateRoot: OData;
  receiptsRoot: OData;
  miner: OData;
  difficulty: OQuantity;
  totalDifficulty: OQuantity;
  extraData: OData;
  size: OQuantity;
  gasLimit: OQuantity;
  gasUsed: OQuantity;
  timestamp: OQuantity;
  transactions: Array<OData | OTransactionObject>;
  uncles: OData[];
}

const TBlockObject = TObject({
  number: TOptional(TQuantity),
  hash: TOptional(TData(32)),
  parentHash: TData(32),
  nonce: TOptional(TData(8)),
  sha3Uncles: TData(32),
  logsBloom: TOptional(TData(256)),
  transactionsRoot: TData(32),
  stateRoot: TData(32),
  receiptsRoot: TData(32),
  miner: TData(32),
  difficulty: TQuantity,
  totalDifficulty: TQuantity,
  extraData: TData(),
  size: TQuantity,
  gasLimit: TQuantity,
  gasUsed: TQuantity,
  timestamp: TQuantity,
  transactions: TArray(TMerge(TData(32), TTransactionObject)),
  uncles: TArray(TData(32)),
});

const Methods = {
  // web3_* methods
  web3_clientVersion: {
    params: <never[]>[],
    pTypes: TVoid,
    result: <string>'',
    rTypes: TString,
  },
  web3_sha3: {
    params: <[IData]>[''],
    pTypes: TTuple(TData()),
    result: <OData>new ArrayBuffer(0),
    rTypes: TData(),
  },

  // // net_* methods
  // net_version: {
  //   params: never[],
  //   result: string,
  // },
  // net_peerCount: {
  //   params: never[],
  //   result: OQuantity,
  // },
  // net_listening: {
  //   params: never[],
  //   result: boolean,
  // },

  // // eth_* account methods
  // eth_coinbase: {
  //   params: never[],
  //   result: string,
  // },
  // eth_accounts: {
  //   params: never[],
  //   result: string[],
  // },
  // eth_getBalance: {
  //   params: [IData, ITag],
  //   result: OQuantity,
  // },
  // eth_getTransactionCount: {
  //   params: [IData, ITag],
  //   result: OQuantity,
  // },
  // eth_sign: {
  //   params: [IData, IData],
  //   result: OData,
  // },

  // // eth_* transaction methods
  // eth_gasPrice: {
  //   params: never[],
  //   result: OQuantity,
  // },
  // eth_estimateGas: {
  //   params: [
  //     {
  //       data: IData,
  //       from: IData,
  //       gas: IQuantity,
  //       gasPrice: IQuantity,
  //       nonce: IQuantity,
  //       to: IData,
  //       value: IQuantity,
  //     },
  //     ITag,
  //   ],
  //   result: OQuantity,
  // },
  // eth_call: {
  //   params: [
  //     {
  //       to: IData,
  //       data: IData,
  //       from: IData,
  //       gas: IQuantity,
  //       gasPrice: IQuantity,
  //       nonce: IQuantity,
  //       value: IQuantity,
  //     },
  //     ITag,
  //   ],
  //   result: OData,
  // },
  // eth_sendTransaction: {
  //   params: [
  //     {
  //       from: IData,
  //       gasPrice: IQuantity,
  //       to: IData,
  //       data: IData,
  //       gas: IQuantity,
  //       nonce: IQuantity,
  //       value: IQuantity,
  //     },
  //     ITag,
  //   ],
  //   result: OData,
  // },
  // eth_sendRawTransaction: {
  //   params: [IData],
  //   result: OData,
  // },
  // eth_getOTransactionReceipt: {
  //   params: [IData],
  //   result: null | OTransactionReceipt,
  // },
  // eth_getTransactionByHash: {
  //   params: [IData],
  //   result: null | OTransactionObject,
  // },
  // eth_getTransactionByBlockHashAndIndex: {
  //   params: [IData, IQuantity],
  //   result: null | OTransactionObject,
  // },
  // eth_getTransactionByBlockNumberAndIndex: {
  //   params: [IQuantity, IQuantity],
  //   result: null | OTransactionObject,
  // },

  // // eth_* block methods
  // eth_blockNumber: {
  //   params: never[],
  //   result: OQuantity,
  // },
  // eth_getStorageAt: {
  //   params: [IData, IQuantity, ITag],
  //   result: OData,
  // },
  // eth_getBlockTransactionCountByHash: {
  //   params: [IData],
  //   result: OQuantity,
  // },
  // eth_getBlockTransactionCountByNumber: {
  //   params: [IQuantity],
  //   result: OQuantity,
  // },
  // eth_getUncleCountByBlockHash: {
  //   params: [IData],
  //   result: OQuantity,
  // },
  // eth_getUncleCountByBlockNumber: {
  //   params: [IQuantity],
  //   result: OQuantity,
  // },
  // eth_getCode: {
  //   params: [IData, ITag],
  //   result: OData,
  // },
  // eth_getBlockByHash: {
  //   params: [IData],
  //   result: null | OBlockObject,
  // },
  // eth_getBlockByNumber: {
  //   params: [IQuantity],
  //   result: null | OBlockObject,
  // },
  // eth_getUncleByBlockHashAndIndex: {
  //   params: [IData, IQuantity],
  //   result: null | OBlockObject,
  // },
  // eth_getUncleByBlockNumberAndIndex: {
  //   params: [IQuantity, IQuantity],
  //   result: null | OBlockObject,
  // },
};

type Type = typeof Methods;
