import {JsonRpc} from '@browseth/internal-types';
import {Transport as TransportTypes} from '@browseth/internal-types';
import {defaultTransport} from '@browseth/transports';

export interface RequestOptions<
  Api extends JsonRpc.ApiAbstract = JsonRpc.ApiAbstract,
  Method extends keyof Api = string
> extends JsonRpc.RequestOptions<Api, Method> {
  url: string;
  headers?: {[key: string]: string | string[]};
  timeout?: number;
  baseUrl?: string;
  credentials?: {
    username: string;
    password: string;
  };
}

export interface Response<
  Api extends JsonRpc.ApiAbstract = JsonRpc.ApiAbstract,
  Method extends keyof Api = string
> extends JsonRpc.Response<Api, Method> {
  headers?: {[key: string]: string | string[]};
  status?: number;
  statusText?: string;
}

let id = 0;
function toTransportRequestOptions<
  Api extends JsonRpc.ApiAbstract,
  Method extends keyof Api
>(opts: RequestOptions): TransportTypes.RequestOptions {
  return {
    headers: {...opts.headers, 'Content-Type': 'application/json'},
    msg: JSON.stringify({
      id: (id += 1),
      jsonrpc: '2.0',
      method: opts.method,
      params: opts.params,
    }),
    timeout: opts.timeout || 30000,
    url: opts.url,
  };
}

export class Client<Api extends JsonRpc.ApiAbstract> {
  public static staticOptions: Partial<RequestOptions<any, any>>;
  public defaultOptions: Partial<RequestOptions<any, any>>;

  constructor(
    public url: string,
    public opts?: Partial<RequestOptions<Api, any>>,
  ) {
    this.defaultOptions = opts || {};
  }

  public async request<Method extends keyof Api>(
    method: Method,
    params: Api[Method]['params'],
    opts?: Partial<RequestOptions<Api, Method>>,
  ): Promise<Response<Api, Method>> {
    const requestOptions = {
      ...Client.staticOptions,
      ...this.defaultOptions,
      ...opts,
      method,
      params,
      url: this.url,
    };

    const resp = await defaultTransport.request(
      toTransportRequestOptions(requestOptions),
    );
    const parsed = JSON.parse(resp.msg);

    if (parsed.error && !parsed.result) {
      throw new Error(
        `${parsed.error.code}:${parsed.error.message}${parsed.error.data &&
          '\n' + parsed.error.data}`,
      );
    } else if (!parsed.result) {
      throw new Error('invalid jsonrpc response');
    }

    return {
      headers: resp.headers,
      requestOptions,
      result: parsed.result,
      status: resp.status,
    };
  }
}

// const a = {
//   web3_sha3: {
//     params: <[IData]>[''],
//     ptypes: [{type: 'data'}],
//     result: [{type: 'string'}],
//   },
// };
// type a = typeof a;

// type I = {
//   web3_sha3: {
//     params: [string];
//     result: [string];
//   };
//   web3_clientVersion: {
//     params: never[];
//     result: [string];
//   };
// };

// const asdf = new DefaultJsonRpc<I>('asdf');
// asdf.request('web3_sha3', ['string']);
