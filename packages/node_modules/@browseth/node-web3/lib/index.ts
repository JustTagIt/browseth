import {
  ApiAbstract,
  RequestObject,
  RequestOptions,
  Response,
  ResponseObject,
} from '@browseth/internal-types/jsonrpc';
import {All} from '@browseth/internal-types/jsonrpc-methods';
import {IData, IQuantity, ITag} from '@browseth/internal-types/jsonrpc-types';

interface ProviderObject<Api extends ApiAbstract> {
  send(payload: RequestObject<keyof Api>): any;
  send(
    payload: RequestObject<keyof Api>,
    cb: (e?: Error, result?: ResponseObject) => void,
  ): void;
  // send(payload:  RequestObject<keyof Api>,cb?: (e: any, result: any) => void): any | void;
  sendAsync?(
    payload: RequestObject<keyof Api>,
    cb: (e?: Error, result?: ResponseObject) => void,
  ): void;
}

function createSend<Api extends ApiAbstract>(
  provider: any,
): (
  payload: RequestObject<keyof Api>,
  cb: (e?: Error, result?: ResponseObject) => void,
) => void {
  if (typeof provider.send !== 'function') {
    throw new TypeError(`provider<${provider}> must have a send method`);
  }

  const typedProvider = <ProviderObject<Api>>provider;

  if (typeof typedProvider.sendAsync !== 'function') {
    return typedProvider.send.bind(typedProvider);
  }
  return typedProvider.sendAsync.bind(typedProvider);
}

export default class Web3<Api extends ApiAbstract = All> {
  public send: <Method extends keyof Api>(
    method: Method,
    params: Api[Method]['params'],
  ) => Api[Method]['result'];

  private id: number = 0;

  constructor(provider: any) {
    const memoizedSend = createSend<Api>(provider);

    this.send = <Method extends keyof Api>(
      method: Method,
      params: Api[Method]['params'],
    ) =>
      new Promise(resolve => {
        memoizedSend(
          {
            id: (this.id += 1),
            jsonrpc: '2.0',
            method,
            params,
          },
          (err?: Error, response?: ResponseObject<Api[Method]['result']>) => {
            if (err) {
              throw err;
            } else if (response === undefined) {
              throw new Error('no response object');
            } else if (response.error && !response.result) {
              throw new Error(
                `${response.error.code}:${response.error.message}${response
                  .error.data && '\n' + response.error.data}`,
              );
            } else if (!response.result) {
              throw new Error('invalid jsonrpc response');
            }

            resolve(response.result);
          },
        );
      });
  }

  public getAccount() {
    return this.send('eth_coinbase', []);
  }

  public getAllAccounts() {
    return this.send('eth_accounts', []);
  }

  public getBalance(address: IData, tag: ITag) {
    throw new Error('Meta-Mask-Provider-Engine has no getBalance');
  }

  public getChainId() {
    return this.send('net_version', []);
  }

  public getGasPrice() {
    // return this.send('eth_gasPrice', []);
    throw new Error('Meta-Mask-Provider-Engine has no getGasPrice');
  }

  public estimateGas(
    transaction: {
      data?: IData;
      from?: IData;
      gas?: IQuantity;
      gasPrice?: IQuantity;
      nonce?: IQuantity;
      to?: IData;
      value?: IQuantity;
    },
    tag: ITag,
  ) {
    return this.send('eth_estimateGas', [transaction, tag]);
  }

  public ethCall(
    transaction: {
      to: IData;
      data?: IData;
      from?: IData;
      gas?: IQuantity;
      gasPrice?: IQuantity;
      nonce?: IQuantity;
      value?: IQuantity;
    },
    tag: ITag,
  ) {
    return this.send('eth_call', [transaction, tag]);
  }

  public sendTransaction(transaction: {
    from: IData;
    gasPrice: IQuantity;
    to: IData;
    data?: IData;
    gas?: IQuantity;
    nonce?: IQuantity;
    value?: IQuantity;
  }) {
    return this.send('eth_sendTransaction', [transaction]);
  }

  public async signMessage(message: IData) {
    return this.send('eth_sign', [await this.getAccount(), message]);
  }
}
