import {Transport} from '@browseth/internal-types';

function isSupported(): boolean {
  return (
    typeof Response !== 'undefined' &&
    Response.prototype.hasOwnProperty('body') &&
    typeof Headers === 'function'
  );
}

// tslint:disable-next-line:only-arrow-functions
export const request = <Transport.Requester>function(opts: any, cb?: any) {
  if (cb) {
    fetchRequest(opts).then(resp => cb(undefined, resp), cb);
    return;
  }

  return fetchRequest(opts);
};

request.isSupported = isSupported;

function rejectAfter(ms: number) {
  return new Promise((_, r) => setTimeout(r, ms));
}

async function fetchRequest(
  opts: Transport.RequestOptions,
): Promise<Transport.Response> {
  return (await Promise.all([
    fetch(opts.url, {
      body: opts.msg,
      credentials: 'same-origin',
      headers:
        opts.headers &&
        new Headers(
          Object.keys(opts.headers).map(v => {
            const value = opts.headers![v];
            return typeof value === 'string'
              ? [v, value]
              : [v, value.join(', ')];
          }),
        ),
    })
      .then(resp => {
        if (resp.ok !== true) {
          throw new Error(`Not ok resp.status<${resp.status}>`);
        }
        return resp;
      })
      .then(async resp => ({
        headers: [...resp.headers.entries()].reduce(
          (a, [k, v]) => ({...a, [k]: v}),
          {},
        ),
        msg: await resp.text(),
        status: resp.status,
      })),
    opts.timeout ? rejectAfter(opts.timeout) : Promise.resolve(),
  ]))[0];
}
